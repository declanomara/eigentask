name: Deploy to Staging

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches: [staging]
  workflow_dispatch: # Allow manual triggering
  push:
    branches:
      - feature/automated-env-deployment-and-volume-persistence  # TEMPORARY: For testing

concurrency:
  group: deploy-staging
  cancel-in-progress: false # Don't cancel - let deployments complete

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only deploy if CI workflow succeeded
    if: |
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'staging') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/feature/automated-env-deployment-and-volume-persistence')  # TEMPORARY: For testing
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy environment files
        env:
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_DEPLOY_PATH: ${{ secrets.STAGING_DEPLOY_PATH || '/opt/eigentask' }}
          STAGING_API_ENV: ${{ secrets.STAGING_API_ENV }}
          STAGING_WEB_ENV: ${{ secrets.STAGING_WEB_ENV }}
          STAGING_APP_DB_ENV: ${{ secrets.STAGING_APP_DB_ENV }}
          STAGING_KEYCLOAK_ENV: ${{ secrets.STAGING_KEYCLOAK_ENV }}
          STAGING_KEYCLOAK_DB_ENV: ${{ secrets.STAGING_KEYCLOAK_DB_ENV }}
        run: |
          # Base64 encode secrets to safely pass through SSH
          # Use -w 0 on Linux, or pipe to tr -d '\n' for cross-platform
          API_ENV_B64=$(echo -n "$STAGING_API_ENV" | base64 | tr -d '\n')
          WEB_ENV_B64=$(echo -n "$STAGING_WEB_ENV" | base64 | tr -d '\n')
          APP_DB_ENV_B64=$(echo -n "$STAGING_APP_DB_ENV" | base64 | tr -d '\n')
          KEYCLOAK_ENV_B64=$(echo -n "$STAGING_KEYCLOAK_ENV" | base64 | tr -d '\n')
          KEYCLOAK_DB_ENV_B64=$(echo -n "$STAGING_KEYCLOAK_DB_ENV" | base64 | tr -d '\n')
          
          ssh ${STAGING_USER}@${STAGING_HOST} bash << EOF
            set -e
            ENV_PATH=\${ENV_FILE_PATH:-/etc/eigentask}
            ENV_DIR="\${ENV_PATH}/staging"
            
            echo "Creating staging environment files directory..."
            sudo mkdir -p "\${ENV_DIR}"
            sudo chown \${USER}:\${USER} "\${ENV_DIR}"
            
            echo "Deploying environment files from GitHub Secrets..."
            
            # Decode and write each env file
            echo '${API_ENV_B64}' | base64 -d | sudo tee "\${ENV_DIR}/api.env" > /dev/null
            echo '${WEB_ENV_B64}' | base64 -d | sudo tee "\${ENV_DIR}/web.env" > /dev/null
            echo '${APP_DB_ENV_B64}' | base64 -d | sudo tee "\${ENV_DIR}/app-db.env" > /dev/null
            echo '${KEYCLOAK_ENV_B64}' | base64 -d | sudo tee "\${ENV_DIR}/keycloak.env" > /dev/null
            echo '${KEYCLOAK_DB_ENV_B64}' | base64 -d | sudo tee "\${ENV_DIR}/keycloak-db.env" > /dev/null
            
            # Set secure permissions
            sudo chmod 600 "\${ENV_DIR}"/*.env
            sudo chown \${USER}:\${USER} "\${ENV_DIR}"/*.env
            
            echo "Environment files deployed successfully!"
            ls -la "\${ENV_DIR}"
          EOF

      - name: Deploy to staging server
        env:
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_DEPLOY_PATH: ${{ secrets.STAGING_DEPLOY_PATH || '/opt/eigentask' }}
        run: |
          ssh ${STAGING_USER}@${STAGING_HOST} << EOF
            set -e
            cd ${STAGING_DEPLOY_PATH}
            
            ENV_PATH=\${ENV_FILE_PATH:-/etc/eigentask}
            
            echo "Verifying environment files exist..."
            REQUIRED_ENV_FILES=(
              "\${ENV_PATH}/staging/api.env"
              "\${ENV_PATH}/staging/web.env"
              "\${ENV_PATH}/staging/app-db.env"
              "\${ENV_PATH}/staging/keycloak.env"
              "\${ENV_PATH}/staging/keycloak-db.env"
            )
            for env_file in "\${REQUIRED_ENV_FILES[@]}"; do
              if [ ! -f "\$env_file" ]; then
                echo "ERROR: Required env file missing: \$env_file"
                exit 1
              fi
            done
            echo "All required env files found."
            
            echo "Pulling latest code from staging branch..."
            git fetch origin
            git checkout staging
            git pull origin staging
            
            echo "Creating Docker networks if they don't exist..."
            docker network create eigentask-staging 2>/dev/null || true
            
            echo "Building and deploying staging containers..."
            ENV_FILE_PATH=\${ENV_PATH} docker compose -f docker-compose.staging.yml pull || true
            ENV_FILE_PATH=\${ENV_PATH} docker compose -f docker-compose.staging.yml build --no-cache
            ENV_FILE_PATH=\${ENV_PATH} docker compose -f docker-compose.staging.yml up -d
            
            echo "Waiting for services to be healthy..."
            sleep 10
            
            echo "Checking service status..."
            ENV_FILE_PATH=\${ENV_PATH} docker compose -f docker-compose.staging.yml ps
            
            echo "Deployment complete!"
          EOF

      - name: Verify deployment
        env:
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_DEPLOY_PATH: ${{ secrets.STAGING_DEPLOY_PATH || '/opt/eigentask' }}
        run: |
          ssh ${STAGING_USER}@${STAGING_HOST} << EOF
            cd ${STAGING_DEPLOY_PATH}
            
            # Check if containers are running
            if ! ENV_FILE_PATH=\${ENV_FILE_PATH:-/etc/eigentask} docker compose -f docker-compose.staging.yml ps | grep -q "Up"; then
              echo "ERROR: Some containers are not running!"
              ENV_FILE_PATH=\${ENV_FILE_PATH:-/etc/eigentask} docker compose -f docker-compose.staging.yml ps
              exit 1
            fi
            
            echo "All services are running successfully"
          EOF
