#!/usr/bin/env python3
"""
Run Alembic migrations in the API container for a given environment.

Usage:
  python scripts/migrate.py [OPTIONS] ENV COMMAND [ARGS...]

  ENV: staging | production | local
  COMMAND: upgrade | downgrade | revision | current | history | stamp

Examples:
  python scripts/migrate.py staging upgrade
  python scripts/migrate.py production upgrade
  python scripts/migrate.py local upgrade
  python scripts/migrate.py staging revision "add sessions table"
  python scripts/migrate.py staging downgrade -1
  python scripts/migrate.py staging current

When run inside the API container (e.g. via docker compose run api ...),
runs Alembic directly. Otherwise uses docker compose exec against the
appropriate stack (staging/production/local).
"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
from pathlib import Path


def find_repo_root() -> Path:
    """Repo root: directory containing docker-compose.yml."""
    root = Path(__file__).resolve().parent.parent
    if (root / "docker-compose.yml").is_file():
        return root
    raise SystemExit("migrate.py: must run from repo root (or repo must contain docker-compose.yml).")


def inside_docker() -> bool:
    return Path("/.dockerenv").exists()


def run_alembic_direct(args: list[str]) -> int:
    """Run alembic in this process (inside container)."""
    import shutil

    alembic = shutil.which("alembic")
    if not alembic:
        print("alembic not found in PATH", file=sys.stderr)
        return 1
    os.chdir("/app")
    return os.execv(alembic, ["alembic"] + args)


def compose_args(env: str, env_file_path: str | None) -> tuple[list[str], dict[str, str]]:
    """Compose file flags and env for the given environment."""
    base = ["-f", "docker-compose.yml"]
    env_vars: dict[str, str] = {}
    if env == "staging":
        base += ["-f", "docker-compose.staging.yml"]
        env_vars["ENV_FILE_PATH"] = env_file_path or "/etc/eigentask"
    elif env == "production":
        base += ["-f", "docker-compose.prod.yml"]
        env_vars["ENV_FILE_PATH"] = env_file_path or "/etc/eigentask"
    elif env == "local":
        base += ["-f", "docker-compose.override.yml"]
    else:
        raise ValueError(f"Unknown environment: {env}")
    return base, env_vars


def run_compose_exec(
    repo_root: Path,
    compose_files: list[str],
    env_vars: dict[str, str],
    alembic_args: list[str],
) -> int:
    """Run docker compose exec api ... uv run alembic <alembic_args>."""
    # Use 'uv run alembic' so the shell runs the CLI from the venv, not the ./alembic/ directory
    cmd = [
        "docker",
        "compose",
        *compose_files,
        "exec",
        "api",
        "bash",
        "-lc",
        "cd /app && exec uv run alembic " + " ".join(_quote(a) for a in alembic_args),
    ]
    env = os.environ.copy()
    env.update(env_vars)
    result = subprocess.run(cmd, cwd=repo_root, env=env)
    return result.returncode


def _quote(s: str) -> str:
    """Escape for bash -lc \"...\"."""
    return "'" + s.replace("'", "'\"'\"'") + "'"


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Run Alembic in the API container for staging, production, or local.",
        epilog="Examples: %(prog)s staging upgrade  |  %(prog)s production revision 'add table'",
    )
    parser.add_argument(
        "env",
        choices=["staging", "production", "local"],
        help="Environment: staging, production, or local (compose override)",
    )
    parser.add_argument(
        "command",
        choices=["upgrade", "downgrade", "revision", "current", "history", "stamp"],
        help="Alembic command",
    )
    parser.add_argument(
        "extra",
        nargs="*",
        help="Extra args (e.g. revision message, or -1 for downgrade -1)",
    )
    parser.add_argument(
        "--env-file-path",
        default=os.environ.get("ENV_FILE_PATH"),
        help="Override ENV_FILE_PATH for staging/production (default: /etc/eigentask)",
    )
    args = parser.parse_args()

    if args.command == "revision" and not args.extra:
        args.extra = ["autogenerated migration"]

    alembic_args: list[str] = []
    if args.command == "upgrade":
        alembic_args = ["upgrade", "head"]
    elif args.command == "downgrade":
        alembic_args = ["downgrade", *(args.extra or ["-1"])]
    elif args.command == "revision":
        msg = " ".join(args.extra) if args.extra else "autogenerated migration"
        alembic_args = ["revision", "--autogenerate", "-m", msg]
    elif args.command == "current":
        alembic_args = ["current"]
    elif args.command == "history":
        alembic_args = ["history"]
    elif args.command == "stamp":
        alembic_args = ["stamp", *(args.extra or ["head"])]

    if inside_docker():
        return run_alembic_direct(alembic_args)

    repo_root = find_repo_root()
    compose_files, env_vars = compose_args(args.env, args.env_file_path)
    return run_compose_exec(repo_root, compose_files, env_vars, alembic_args)


if __name__ == "__main__":
    sys.exit(main())
